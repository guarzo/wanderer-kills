- [ ] Refactor the codebase to adopt a domain-driven context layout by grouping related modules under feature-specific directories in `lib/wanderer_kills/` (e.g. `Killmails`, `ShipTypes`, `Systems`, `ESI`, `ZKB`, `Cache`)—define a clear public API for each context and move helper functions into private submodules.  
- [ ] Replace the generic `infrastructure/` folder by splitting its contents into descriptive modules—e.g. move configuration logic to `WandererKills.Config`, time utilities to `WandererKills.Clock`, ETS helpers to `WandererKills.Cache`—and consider renaming the folder to `core` or `util` to better reflect cross-cutting concerns.  
- [ ] Consolidate all time and clock logic by merging existing clock-related modules into a single `WandererKills.Clock` module that exposes functions like `now/0`, `to_unix/1`, `hours_ago/1`, and remove redundant time handlers.  
- [ ] Create a unified `WandererKills.CSV` helper module for CSV parsing—implement functions such as `read_file/2`, `parse_row/1`, `parse_type_row/1`, and `parse_group_row/1`—and refactor `ship_type_parser.ex` and `csv_util.ex` to delegate to it, deleting their duplicate code.  
- [ ] Audit and prune legacy compatibility code by identifying deprecated branches and helper functions (e.g. old RedisQ or ZKB formats), verifying they’re unused, and safely removing them along with associated tests.  -- Analysis on in-use kill formats saved in docs/FORMAT_ANALYSIS.md
- [ ] Define shared behaviours in `WandererKills.Data.Behaviours` (e.g. `@callback fetch(args) :: {:ok, result} | {:error, reason}`) for common patterns like HTTP fetchers and cache stores, then implement those behaviours in your ESI and ZKB client modules to reduce ad-hoc code.  
- [ ] Refactor all direct `Application.compile_env/3` calls into a centralized `WandererKills.Config` module that wraps environment lookups, provides defaults, and performs validations—then replace each scattered compile_env call with a call to this wrapper.  
- [ ] Break down oversized modules (for example `External.ESI.Client` and `External.ZKB.RedisQ`) into smaller, single-responsibility modules (e.g. `ESI.TypeFetcher`, `ESI.GroupFetcher`, `ESI.KillmailFetcher`) organized under a clear namespace.  
- [ ] Simplify complex control flows by refactoring nested `case` and `with` blocks into pipelines and pattern-matched function clauses, extracting intermediate steps into private helper functions for readability and maintainability.  
- [ ] Standardize naming conventions across the codebase—normalize acronyms (e.g. always use `ZKB` or `RedisQ`, not both), prefix all modules with the `WandererKills` context, and rename overly generic modules like `Infrastructure.Error` to `WandererKills.Error`.  
- [ ] Centralize error handling by creating a single `WandererKills.Error` module that defines all custom error structs and helper functions, then convert all disparate error tuple patterns (e.g. `{:error, reason}` from cache vs infrastructure) to use this unified module.  
- [ ] Add `child_spec/1` functions to each GenServer and Supervisor module to encapsulate `start_link` options (e.g. `name`, `restart`), and simplify your top-level `WandererKills.Application` supervisor to reference modules directly rather than manually constructing child specs.  
